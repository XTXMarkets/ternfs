{{define "body"}}
    <script src="/chart-4.3.0.js"></script>
    <script>
        window.data = JSON.parse({{.Timings}})
    </script>
    <div>
        <input type="datetime-local" id="time-from" required> â€” <input type="datetime-local" id="time-to" required>
        <div id="charts"></div>
    </div>
    <script>(() => {
        // Function to format a Date into the 'yyyy-mm-ddThh:mm' format required by datetime-local inputs
        function formatLocalDate(date) {
            const year = date.getFullYear();
            const month = ('0' + (date.getMonth()+1)).slice(-2); // months are zero-based in JavaScript
            const day = ('0' + date.getDate()).slice(-2);
            const hours = ('0' + date.getHours()).slice(-2);
            const minutes = ('0' + date.getMinutes()).slice(-2);
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        
        const chartsEl = document.getElementById('charts');
        
        function combineHistograms(old, timings) {
            old = old || {
                histogram: [],
                count: 0,
                meanMs: 0,
            };
            let count = 0;
            for (let i = 0; i < timings.Histogram.length; i++) {
                const bin = timings.Histogram[i];
                count += bin.Count;
                if (!old.histogram[i]) {
                    old.histogram[i] = {
                        upperBoundMs: bin.UpperBoundMs,
                        count: 0,
                    }
                } else if (old.histogram[i].upperBoundMs != bin.UpperBoundMs) {
                    throw `Differing upper bounds for ${fullNameWithKind} at ${i}, ${old.histogram[i].upperBoundMs} != ${bin.UpperBoundMs}`;
                }
                old.histogram[i].upperBoundMs = bin.UpperBoundMs;
                old.histogram[i].count += bin.Count;
            } 
            return old;
        }

        function formatMs(ms) {
            const twoDec = (x) => (Math.round(x*100) / 100).toFixed(2);
            if (ms > 1000) {
                return twoDec(ms/1000) + 's';
            }
            if (ms < 1) {
                return twoDec(ms*1000) + 'us'
            }
            return twoDec(ms) + 'ms';
        }

        function drawChart(el, req, timings) {
            const chartEl = document.createElement('canvas');
            el.appendChild(chartEl);
            new Chart(chartEl, {
                type: 'line',
                data: {
                    labels: timings.histogram.map(({upperBoundMs}) => `< ${formatMs(upperBoundMs)}`),
                    datasets: [{ label: req, data: timings.histogram.map(({count}) => count) }],
                },
            });
        }
        
        function redraw() {
            console.log('redrawing');
            
            // erase everything
            chartsEl.innerHTML = '';
            
            // get current boundaries
            const timeFrom = new Date(timeFromEl.value);
            const timeTo = new Date(timeToEl.value);

            // filter and sum histograms    
            const data = {};
            for (const [timingsName, timedTimings] of Object.entries(window.data)) {
                for (const timings of timedTimings) {
                    const time = new Date(timings.Time);
                    if (time.getTime() < timeFrom.getTime() || time.getTime() > timeTo.getTime()) {
                        continue;
                    }
                    const segments = timingsName.split('.');
                    const group = segments[0];
                    let req = segments[1];
                    if (group === 'shard') {
                        req = segments[2];
                    }
                    data[group] = data[group] || {};
                    data[group][req] = combineHistograms(data[group][req], timings);
                }
            }

            // trim histos
            for (const groupData of Object.values(data)) {
                for (const reqData of Object.values(groupData)) {
                    let skipStart = 0;
                    for (; skipStart < reqData.histogram.length && reqData.histogram[skipStart].count == 0; skipStart++) {}
                    let skipEnd = 0;
                    for (; skipEnd < reqData.histogram.length && reqData.histogram[reqData.histogram.length-skipEnd-1].count == 0; skipEnd++) {}
                    reqData.histogram = reqData.histogram.slice(skipStart, reqData.histogram.length-skipEnd);
                }
            }
            
            // now draw the divs
            for (const [group, groupData] of Object.entries(data)) {
                const groupEl = document.createElement('h2');
                groupEl.innerHTML = group;
                chartsEl.appendChild(groupEl);
                const reqsEl = document.createElement('div');
                chartsEl.appendChild(reqsEl);
                reqsEl.style.display = 'grid';
                reqsEl.style.gridTemplateColumns = '33% 33% 33%';
                for (const [req, reqData] of Object.entries(groupData)) {
                    const chartContainerEl = document.createElement('div');
                    reqsEl.appendChild(chartContainerEl);
                    chartContainerEl.style.width = '100%';
                    drawChart(chartContainerEl, req, reqData);
                }
            }
        }
        
        const timeFromEl = document.getElementById('time-from');
        const timeToEl = document.getElementById('time-to');
        
        // set initial times (now-24hrs and now)
        timeFromEl.value = formatLocalDate(new Date(new Date().getTime() - 24 * 60 * 60 * 1000));
        timeToEl.value = formatLocalDate(new Date());
        
        // redraw when changed
        timeFromEl.addEventListener('change', redraw);
        timeToEl.addEventListener('change', redraw);
        
        redraw();
    })();</script>
{{end}}
