# Stubs for sortedcontainers (Python 3)
# (so far just SortedDict is necessary)

from typing import (AbstractSet, Any, Callable, Dict, Generic,
    ItemsView as AbstractItemsView, KeysView as AbstractKeysView, Iterable,
    Iterator, List, Mapping, Optional, overload, Set, Sequence, Tuple, TypeVar,
    Union, ValuesView as AbstractValuesView)

from _collections_abc import dict_keys, dict_items, dict_values

_KT = TypeVar('_KT')
_VT = TypeVar('_VT')
_S = TypeVar('_S')
_T = TypeVar('_T')
_KeyFunc = Callable[[_KT], Any]
_DictInit = Union[Mapping[_KT, _VT], Iterable[Tuple[_KT, _VT]]]


class _IlocWrapper(Generic[_KT, _VT]):
    def __init__(self, _dict: SortedDict[_KT, _VT]) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> _VT: ...
    def __delitem__(self, index: int) -> None: ...


class SortedDict(Dict[_KT, _VT]):
    def bisect_left(self, val: _KT) -> int: ...
    def bisect(self, val: _KT) -> int: ...
    def bisect_right(self, val: _KT) -> int: ...
    def index(self, val: _KT, start: Optional[int] = None,
        stop: Optional[int] = None) -> int: ...
    def irange(self, minimum: Optional[_KT] = None,
        maximum: Optional[_KT] = None,
        inclusive: Tuple[bool, bool] = (True, True),
        reverse: bool = False) -> Iterator[_KT]: ...
    def islice(self, start: Optional[int] = None, stop: Optional[int] = None,
        reverse: bool = False) -> Iterator[_KT]: ...
    def bisect_key_left(self, key: Any) -> int: ...
    def bisect_key(self, key: Any) -> int: ...
    def bisect_key_right(self, key: Any) -> int: ...
    def irange_key(self, min_key: Any = None, max_key: Any = None,
        inclusive: Tuple[bool, bool] = (True, True), reverse: bool = False
        ) -> Iterator[_KT]: ...
    iloc: _IlocWrapper[_KT, _VT] = ...
    @overload
    def __init__(self, _KT: Optional[_KeyFunc[_KT]], m: _DictInit[_KT, _VT],
        **kwargs: _VT) -> None: ...
    @overload
    def __init__(self, m: _DictInit[_KT, _VT], **kwargs: _VT) -> None: ...
    @overload
    def __init__(self, **kwargs: _VT) -> None: ...
    @property
    def key(self) -> Optional[_KeyFunc[_KT]]: ...
    def clear(self) -> None: ...
    def __delitem__(self, key: _KT) -> None: ...
    def __iter__(self) -> Iterator[_KT]: ...
    def __reversed__(self) -> Iterator[_KT]: ...
    def __setitem__(self, key: _KT, value: _VT) -> None: ...
    def copy(self) -> SortedDict[_KT, _VT]: ...
    def items(self) -> ItemsView[_KT, _VT]: ... # type: ignore[override]
    def iteritems(self) -> Iterator[Tuple[_KT, _VT]]: ...
    def keys(self) -> KeysView[_KT]: ... # type: ignore[override]
    def iterkeys(self) -> Iterator[_KT]: ...
    def values(self) -> ValuesView[_VT]: ... # type: ignore[override]
    def itervalues(self) -> Iterator[_VT]: ...
    @overload
    def pop(self, key: _KT) -> _VT: ...
    @overload
    def pop(self, key: _KT, default: Union[_VT, _T] = ...
        ) -> Union[_VT, _T]: ...
    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...
    def peekitem(self, index: int = ...) -> Tuple[_KT, _VT]: ...
    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...
    def viewkeys(self) -> KeysView[_KT]: ...
    def viewvalues(self) -> ValuesView[_VT]: ...
    def viewitems(self) -> ItemsView[_KT, _VT]: ...
    def __reduce__(self
        ) -> Tuple[Callable[..., SortedDict[_KT, _VT]], Tuple[Any, ...]]: ...


class KeysView(AbstractKeysView[_KT], AbstractSet[_KT], Sequence[_KT]):
    def __init__(self, sorted_dict: SortedDict[_KT, Any]) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: object) -> bool: ...
    def __iter__(self) -> Iterator[_KT]: ...
    @overload
    def __getitem__(self, i: int) -> _KT: ...
    @overload
    def __getitem__(self, s: slice) -> Sequence[_KT]: ...
    def __reversed__(self) -> Iterator[_KT]: ...
    def index(self, value: _KT, start: Optional[int] = ...,
        stop: Optional[int] = ...) -> int: ...
    def count(self, value: _KT) -> int: ...
    def __eq__(self, that: object) -> bool: ...
    def __ne__(self, that: object) -> bool: ...
    def __lt__(self, that: AbstractSet[Any]) -> bool: ...
    def __gt__(self, that: AbstractSet[Any]) -> bool: ...
    def __le__(self, that: AbstractSet[Any]) -> bool: ...
    def __ge__(self, that: AbstractSet[Any]) -> bool: ...

    # TODO: these actually return SortedSet (which isa Set)
    def __and__(self, that: Iterable[Any]) -> Set[_KT]: ...
    def __or__(self, that: Iterable[_T]) -> Set[Union[_KT, _T]]: ...
    def __sub__(self, that: Iterable[Any]) -> Set[_KT]: ...
    def __xor__(self, that: Iterable[_T]) -> Set[Union[_KT, _T]]: ...

    def isdisjoint(self, that: Iterable[_KT]) -> bool: ...


class ValuesView(AbstractValuesView[_VT], Sequence[_VT]):
    def __init__(self, sorted_dict: SortedDict[Any, _VT]) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, value: object) -> bool: ...
    def __iter__(self) -> Iterator[_VT]: ...
    @overload
    def __getitem__(self, i: int) -> _VT: ...
    @overload
    def __getitem__(self, s: slice) -> Sequence[_VT]: ...
    def __reversed__(self) -> Iterator[_VT]: ...
    def index(self, value: _VT, start: int = ..., end: int = ...) -> int: ...
    def count(self, value: _VT) -> int: ...


class ItemsView(AbstractItemsView[_KT, _VT], AbstractSet[Tuple[_KT, _VT]], Sequence[Tuple[_KT, _VT]]):
    def __init__(self, sorted_dict: SortedDict[_KT, _VT]) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: object) -> bool: ...
    def __iter__(self) -> Iterator[Tuple[_KT, _VT]]: ...
    @overload
    def __getitem__(self, i: int) -> Tuple[_KT, _VT]: ...
    @overload
    def __getitem__(self, s: slice) -> List[Tuple[_KT, _VT]]: ...
    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...
    def index(self, key: Tuple[_KT, _VT], start: Optional[int] = ...,
        stop: Optional[int] = ...) -> int: ...
    def count(self, item: Tuple[_KT, _VT]) -> int: ...
    def __eq__(self, that: object) -> bool: ...
    def __ne__(self, that: object) -> bool: ...
    def __lt__(self, that: AbstractSet[Any]) -> bool: ...
    def __gt__(self, that: AbstractSet[Any]) -> bool: ...
    def __le__(self, that: AbstractSet[Any]) -> bool: ...
    def __ge__(self, that: AbstractSet[Any]) -> bool: ...

    # TODO: these actually return SortedSet (which isa Set)
    def __and__(self, that: Iterable[Any]) -> Set[Tuple[_KT, _VT]]: ...
    def __or__(self, that: Iterable[_T]) -> Set[Union[Tuple[_KT, _VT], _T]]: ...
    def __sub__(self, that: Iterable[Any]) -> Set[Tuple[_KT, _VT]]: ...
    def __xor__(self, that: Iterable[_T]) -> Set[Union[Tuple[_KT, _VT], _T]]: ...

    def isdisjoint(self, that: Iterable[Tuple[_KT, _VT]]) -> bool: ...
